#!/usr/bin/env bash
# KeyEnv GitHub Action - Core functions
# These functions are extracted for testing purposes

set -euo pipefail

# Validate required inputs
# Returns 0 if valid, 1 if invalid with error message on stderr
validate_inputs() {
  local token="${1:-}"
  local environment="${2:-}"

  if [ -z "${token}" ]; then
    echo "Input 'token' is required" >&2
    return 1
  fi

  if [ -z "${environment}" ]; then
    echo "Input 'environment' is required" >&2
    return 1
  fi

  return 0
}

# Parse user response to extract project_id from project_ids array
# Arguments: $1 = JSON response body
# Returns: first project_id or empty string
parse_user_response() {
  local body="${1:-}"
  echo "${body}" | jq -r '.project_ids[0] // empty'
}

# Parse secrets response
# Arguments: $1 = JSON response body
# Returns: JSON array of secrets or exits with error
parse_secrets_response() {
  local body="${1:-}"

  if ! echo "${body}" | jq -e '.secrets' > /dev/null 2>&1; then
    echo "Invalid response: Expected JSON with 'secrets' array" >&2
    return 1
  fi

  echo "${body}" | jq -c '.secrets'
}

# Get secret count from response
# Arguments: $1 = JSON response body
# Returns: count as integer
get_secret_count() {
  local body="${1:-}"
  echo "${body}" | jq -r '.secrets | length'
}

# Check if value needs quoting for .env file
# Arguments: $1 = value
# Returns: 0 if needs quoting, 1 otherwise
needs_env_quoting() {
  local value="${1:-}"

  # Check for newlines, quotes, or spaces
  if [[ "${value}" == *$'\n'* ]] || [[ "${value}" == *'"'* ]] || [[ "${value}" == *\'* ]] || [[ "${value}" == *' '* ]]; then
    return 0
  fi

  return 1
}

# Escape value for .env file format
# Arguments: $1 = value
# Returns: escaped value (without surrounding quotes)
escape_env_value() {
  local value="${1:-}"
  printf '%s' "${value}" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

# Format a single secret as .env line
# Arguments: $1 = key, $2 = value
# Returns: formatted line
format_env_line() {
  local key="${1:-}"
  local value="${2:-}"

  if needs_env_quoting "${value}"; then
    local escaped
    escaped=$(escape_env_value "${value}")
    echo "${key}=\"${escaped}\""
  else
    echo "${key}=${value}"
  fi
}

# Check if value is multiline (for GITHUB_ENV heredoc format)
# Arguments: $1 = value
# Returns: 0 if multiline, 1 otherwise
is_multiline() {
  local value="${1:-}"
  [[ "${value}" == *$'\n'* ]]
}

# Generate .env file header
# Arguments: $1 = environment name
# Returns: header lines
generate_env_header() {
  local environment="${1:-}"
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || echo "unknown")

  echo "# Generated by KeyEnv GitHub Action"
  echo "# Environment: ${environment}"
  echo "# Generated at: ${timestamp}"
  echo ""
}

# Map HTTP status to error message
# Arguments: $1 = HTTP status code
# Returns: error message or empty if status is OK
http_error_message() {
  local status="${1:-0}"

  case "${status}" in
    200|201|204)
      echo ""
      ;;
    401)
      echo "Authentication failed. Please check your KeyEnv token."
      ;;
    403)
      echo "Access denied. The token may not have access to this project or environment."
      ;;
    404)
      echo "Project or environment not found. Please verify project-id and environment inputs."
      ;;
    *)
      if [ "${status}" -ge 400 ]; then
        echo "KeyEnv API error (HTTP ${status})"
      else
        echo ""
      fi
      ;;
  esac
}
